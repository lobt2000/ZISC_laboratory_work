{"version":3,"file":"scripts.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,MAAM;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;;AAEA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,eAAe;AACrC;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,sBAAsB;AAC5C;;AAEA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA,kBAAkB,iDAAiD;AACnE;AACA,yBAAyB,iDAAiD;AAC1E;AACA;AACA;AACA,2BAA2B,iDAAiD;AAC5E;;AAEA;AACA;AACA;AACA,uCAAuC,kGAAkG;AACzI;AACA;AACA,oCAAoC,iBAAiB;;AAErD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC","sources":["src\\assets\\stenography\\steganography.js"],"sourcesContent":["/*\n * steganography.js v1.0.3 2017-09-22\n *\n * Copyright (C) 2012 Peter Eigenschink (http://www.peter-eigenschink.at/)\n * Dual-licensed under MIT and Beerware license.\n */\n;\n(function (name, context, factory) {\n\n  // Supports UMD. AMD, CommonJS/Node.js and browser context\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = factory();\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory);\n  } else {\n    context[name] = factory();\n  }\n\n})(\"steg\", this, function () {\n  var Cover = function Cover() {};\n  var util = {\n    \"isPrime\": function (n) {\n      if (isNaN(n) || !isFinite(n) || n % 1 || n < 2) return false;\n      if (n % 2 === 0) return (n === 2);\n      if (n % 3 === 0) return (n === 3);\n      var m = Math.sqrt(n);\n      for (var i = 5; i <= m; i += 6) {\n        if (n % i === 0) return false;\n        if (n % (i + 2) === 0) return false;\n      }\n      return true;\n    },\n    \"findNextPrime\": function (n) {\n      for (var i = n; true; i += 1)\n        if (util.isPrime(i)) return i;\n    },\n    \"sum\": function (func, end, options) {\n      var sum = 0;\n      options = options || {};\n      for (var i = options.start || 0; i < end; i += (options.inc || 1))\n        sum += func(i) || 0;\n\n      return (sum === 0 && options.defValue ? options.defValue : sum);\n    },\n    \"product\": function (func, end, options) {\n      var prod = 1;\n      options = options || {};\n      for (var i = options.start || 0; i < end; i += (options.inc || 1))\n        prod *= func(i) || 1;\n\n      return (prod === 1 && options.defValue ? options.defValue : prod);\n    },\n    \"createArrayFromArgs\": function (args, index, threshold) {\n      var ret = new Array(threshold - 1);\n      for (var i = 0; i < threshold; i += 1)\n        ret[i] = args(i >= index ? i + 1 : i);\n\n      return ret;\n    },\n    \"loadImg\": function (url) {\n      var image = new Image();\n      image.src = url;\n      return image;\n    }\n  };\n\n  Cover.prototype.config = {\n    \"t\": 3,\n    \"threshold\": 1,\n    \"codeUnitSize\": 16,\n    \"args\": function (i) {\n      return i + 1;\n    },\n    \"messageDelimiter\": function (modMessage, threshold) {\n      var delimiter = new Array(threshold * 3);\n      for (var i = 0; i < delimiter.length; i += 1)\n        delimiter[i] = 255;\n\n      return delimiter;\n    },\n    \"messageCompleted\": function (data, i, threshold) {\n      var done = true;\n      for (var j = 0; j < 16 && done; j += 1) {\n        done = done && (data[i + j * 4] === 255);\n      }\n      return done;\n    }\n  };\n  Cover.prototype.getHidingCapacity = function (image, options) {\n    options = options || {};\n    var config = this.config;\n\n    var width = options.width || image.width,\n      height = options.height || image.height,\n      t = options.t || config.t,\n      codeUnitSize = options.codeUnitSize || config.codeUnitSize;\n    return t * width * height / codeUnitSize >> 0;\n  };\n  Cover.prototype.encode = function (message, image, options) {\n    // Handle image url\n    if (image.length) {\n      image = util.loadImg(image);\n    } else if (image.src) {\n      image = util.loadImg(image.src);\n    } else if (!(image instanceof HTMLImageElement)) {\n      throw new Error('IllegalInput: The input image is neither an URL string nor an image.');\n    }\n\n    options = options || {};\n    var config = this.config;\n\n    var t = options.t || config.t,\n      threshold = options.threshold || config.threshold,\n      codeUnitSize = options.codeUnitSize || config.codeUnitSize,\n      prime = util.findNextPrime(Math.pow(2, t)),\n      args = options.args || config.args,\n      messageDelimiter = options.messageDelimiter || config.messageDelimiter;\n\n    if (!t || t < 1 || t > 7) throw new Error('IllegalOptions: Parameter t = \" + t + \" is not valid: 0 < t < 8');\n\n    var shadowCanvas = document.createElement('canvas'),\n      shadowCtx = shadowCanvas.getContext('2d');\n\n    shadowCanvas.style.display = 'none';\n    shadowCanvas.width = options.width || image.width;\n    shadowCanvas.height = options.height || image.height;\n    if (options.height && options.width) {\n      shadowCtx.drawImage(image, 0, 0, options.width, options.height);\n    } else {\n      shadowCtx.drawImage(image, 0, 0);\n    }\n\n    var imageData = shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height),\n      data = imageData.data;\n\n    // bundlesPerChar ... Count of full t-bit-sized bundles per Character\n    // overlapping ... Count of bits of the currently handled character which are not handled during each run\n    // dec ... UTF-16 Unicode of the i-th character of the message\n    // curOverlapping ... The count of the bits of the previous character not handled in the previous run\n    // mask ... The raw initial bitmask, will be changed every run and if bits are overlapping\n    var bundlesPerChar = codeUnitSize / t >> 0,\n      overlapping = codeUnitSize % t,\n      modMessage = [],\n      decM, oldDec, oldMask, left, right,\n      dec, curOverlapping, mask;\n\n    var i, j;\n    for (i = 0; i <= message.length; i += 1) {\n      dec = message.charCodeAt(i) || 0;\n      curOverlapping = (overlapping * i) % t;\n      if (curOverlapping > 0 && oldDec) {\n        // Mask for the new character, shifted with the count of overlapping bits\n        mask = Math.pow(2, t - curOverlapping) - 1;\n        // Mask for the old character, i.e. the t-curOverlapping bits on the right\n        // of that character\n        oldMask = Math.pow(2, codeUnitSize) * (1 - Math.pow(2, -curOverlapping));\n        left = (dec & mask) << curOverlapping;\n        right = (oldDec & oldMask) >> (codeUnitSize - curOverlapping);\n        modMessage.push(left + right);\n\n        if (i < message.length) {\n          mask = Math.pow(2, 2 * t - curOverlapping) * (1 - Math.pow(2, -t));\n          for (j = 1; j < bundlesPerChar; j += 1) {\n            decM = dec & mask;\n            modMessage.push(decM >> (((j - 1) * t) + (t - curOverlapping)));\n            mask <<= t;\n          }\n          if ((overlapping * (i + 1)) % t === 0) {\n            mask = Math.pow(2, codeUnitSize) * (1 - Math.pow(2, -t));\n            decM = dec & mask;\n            modMessage.push(decM >> (codeUnitSize - t));\n          } else if (((((overlapping * (i + 1)) % t) + (t - curOverlapping)) <= t)) {\n            decM = dec & mask;\n            modMessage.push(decM >> (((bundlesPerChar - 1) * t) + (t - curOverlapping)));\n          }\n        }\n      } else if (i < message.length) {\n        mask = Math.pow(2, t) - 1;\n        for (j = 0; j < bundlesPerChar; j += 1) {\n          decM = dec & mask;\n          modMessage.push(decM >> (j * t));\n          mask <<= t;\n        }\n      }\n      oldDec = dec;\n    }\n\n    // Write Data\n    var offset, index, subOffset, delimiter = messageDelimiter(modMessage, threshold),\n      q, qS;\n    for (offset = 0;\n      (offset + threshold) * 4 <= data.length && (offset + threshold) <= modMessage.length; offset += threshold) {\n      qS = [];\n      for (i = 0; i < threshold && i + offset < modMessage.length; i += 1) {\n        q = 0;\n        for (j = offset; j < threshold + offset && j < modMessage.length; j += 1)\n          q += modMessage[j] * Math.pow(args(i), j - offset);\n        qS[i] = (255 - prime + 1) + (q % prime);\n      }\n      for (i = offset * 4; i < (offset + qS.length) * 4 && i < data.length; i += 4)\n        data[i + 3] = qS[(i / 4) % threshold];\n\n      subOffset = qS.length;\n    }\n    // Write message-delimiter\n    for (index = (offset + subOffset); index - (offset + subOffset) < delimiter.length && (offset + delimiter.length) * 4 < data.length; index += 1)\n      data[(index * 4) + 3] = delimiter[index - (offset + subOffset)];\n    // Clear remaining data\n    for (i = ((index + 1) * 4) + 3; i < data.length; i += 4) data[i] = 255;\n\n    imageData.data = data;\n    shadowCtx.putImageData(imageData, 0, 0);\n\n    return shadowCanvas.toDataURL();\n  };\n\n  Cover.prototype.decode = function (image, options) {\n    // Handle image url\n    if (image.length) {\n      image = util.loadImg(image);\n    } else if (image.src) {\n      image = util.loadImg(image.src);\n    } else if (!(image instanceof HTMLImageElement)) {\n      throw new Error('IllegalInput: The input image is neither an URL string nor an image.');\n    }\n\n    options = options || {};\n    var config = this.config;\n\n    var t = options.t || config.t,\n      threshold = options.threshold || config.threshold,\n      codeUnitSize = options.codeUnitSize || config.codeUnitSize,\n      prime = util.findNextPrime(Math.pow(2, t)),\n      args = options.args || config.args,\n      messageCompleted = options.messageCompleted || config.messageCompleted;\n\n    if (!t || t < 1 || t > 7) throw new Error('IllegalOptions: Parameter t = \" + t + \" is not valid: 0 < t < 8');\n\n    var shadowCanvas = document.createElement('canvas'),\n      shadowCtx = shadowCanvas.getContext('2d');\n\n    shadowCanvas.style.display = 'none';\n    shadowCanvas.width = options.width || image.width;\n    shadowCanvas.height = options.width || image.height;\n    if (options.height && options.width) {\n      shadowCtx.drawImage(image, 0, 0, options.width, options.height);\n    } else {\n      shadowCtx.drawImage(image, 0, 0);\n    }\n\n    var imageData = shadowCtx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height),\n      data = imageData.data,\n      modMessage = [],\n      q;\n\n    var i, k, done;\n    if (threshold === 1) {\n      for (i = 3, done = false; !done && i < data.length && !done; i += 4) {\n        done = messageCompleted(data, i, threshold);\n        if (!done) modMessage.push(data[i] - (255 - prime + 1));\n      }\n    }\n\n    var message = \"\",\n      charCode = 0,\n      bitCount = 0,\n      mask = Math.pow(2, codeUnitSize) - 1;\n    for (i = 0; i < modMessage.length; i += 1) {\n      charCode += modMessage[i] << bitCount;\n      bitCount += t;\n      if (bitCount >= codeUnitSize) {\n        message += String.fromCharCode(charCode & mask);\n        bitCount %= codeUnitSize;\n        charCode = modMessage[i] >> (t - bitCount);\n      }\n    }\n    if (charCode !== 0) message += String.fromCharCode(charCode & mask);\n\n    return message;\n  };\n\n  return new Cover();\n});\n"],"names":[],"sourceRoot":"webpack:///"}